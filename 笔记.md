mybatis源码笔记：
 mybatis要运行，大致分为了三步：
  1.获取数据源
  2.获取待执行的sql
  3.执行
   
  String resource = "mybatis-config.xml";
  InputStream inputStream = Resources.getResourceAsStream(resource);
  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
  SqlSession sqlSession = sqlSessionFactory.openSession();
  OperChannel operChannel = sqlSession.selectOne("com.springsource.study.mybatis.OperChannelMapper.selectAll",1);
  
  
  <configuration>
      <environments default="development">
          <environment id="development">
              <transactionManager type="JDBC"></transactionManager>
              <dataSource type="POOLED">
                  <property name="driver" value="com.mysql.jdbc.Driver"/>
                  <property name="url" value="jdbc:mysql://localhost:3306/znyd"/>
                  <property name="username" value="root"/>
                  <property name="password" value="root"/>
              </dataSource>
          </environment>
      </environments>
  
      <mappers>
          <mapper resource="mybatis/operchannel.xml"></mapper>
      </mappers>
  </configuration>
  
  
  
   
  
  首先要知道一点：configuration对应着configuration类
  environment节点对应着environment对象 DataSource是包装在environment中
  
  源码从sqlSessionFactoryBuilder()的build方法开始看起
   1.首先获取到mybatis配置文件中的configuration节点
     parseConfiguration(parser.evalNode("/configuration"));
     
   2.解析配置文件中的environment节点，获取到事务管理器，然后获取到DataSource的type类型
    根据type获取到一个DataSourceFactory(这里是调用的Resources.classForName(string),其实底层就是调用了Class.forName),从DataSourcefactory中get到一个DataSource
    并将DataSource封装在environment对象中
   3.获取到数据源之后，解析mapper.xml文件，根据配置文件中的配置来解析
     mybatis解析mapper文件有四种方法：分别是package > resource > url > mapperClass
     解析到mapper.xml配置文件之后，会获取到当前的namespace,并循环遍历所有的select update insert delete
     将每个sql语句包装成mappedStatement对象,并将该对象存放到了mappedStatements这个map中，map的key是namespace+id(id指的是select标签的id)
     
     在将mappedStatement放到map中之后，会将当前namespace作为key，new MapperProxyFactory<>(type)作为value存到一个map中knownMappers(在通过getMapper这种方式执行SQL的时候会用到)
     
     至此：可以理解为已经获取到了要执行的SQL;要执行的SQL保存在mappedStatement对象中的SqlSource对象中
     
   4.执行查询语句
     首先根据select语句中的第一个入参从mappedStatements这个map中获取到mappedStatement对象
     如果是采用的sqlSession.getMapper方法，那这时候会先从 knownMappers 中，根据入参的类型(mapperInterface.class)，获取到mapperProxyFactory，然后通过jdk动态代理，创建接口对应的代理对象，然后调用目标方法
     调用目标方法的时候，会调用mapperProxy.invoke方法，在这个方法里面，调用对应的selectOne或者selectList
     在执行查询的时候，会先创建cachekey,然后从db中查询数据，查询的时候用的是prepareStatement.execute方法
     关于一级缓存这里，后面在详细学习
    
    
    
  selectOne 也是调用的selectList,在selectList返回数据之后，如果长度为1，就取list.get(0),否则的话，就报错
  
  
  
  ------------------------------------------------
  mybatis和spring整合之后，mapperScannerRegistrar也会调用doScan()来扫描包下的所有.class文件，这里的doScan和spring在扫描bean的时候，用的doScan是一样的，但是不一样的地方在：在获取到所有的.class文件之后，会遍历每个class文件，然后生成ScannedGenericBeanDefinition对象，在this.isCandidateComponent((AnnotatedBeanDefinition)sbd) 判断当前bean是否需要注入的时候，mybatis和spring是调用不同的方法
   spring调用的是
     org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isCandidateComponent(org.springframework.beans.factory.annotation.AnnotatedBeanDefinition)
  
   mybatis调用的是
     org.mybatis.spring.mapper.ClassPathMapperScanner#isCandidateComponent
  
   需要注意的是：
     ClassPathMapperScanner是ClassPathScanningCandidateComponentProvider的子类，
  
   所以，mybatis和spring整合之后，mapperScannerRegistrar只会注入mybatis的接口，spring只会注入ComponentScan注解要扫描的包(spring @Component这些注解修饰的类)
   
   
   ------------------------------------------------
   
   无论是package/url/class/resource，都会有两个内容：
      1.把当前select、update、insert、delete封装成一个mappedStatement,然后把mappedStatement存到一个map中，key值是namespace+id(select节点的id),value 是刚才build的mappedStatement
      2.把当前class，存放到另外一个map；knownMappers.put(type, new MapperProxyFactory<>(type));
      mappedStatement在使用sqlSesison.selectOne()查询的时候，会先根据入参中的全类名+方法名，从mappedStatement获取value
      如果是使用的sqlSession.getMapper();则会根据入参中的class从knowMappers中获取mapperProxyFactory,然后mapperProxyFactory.newInstance(sqlSession);生成当前mapperInterface的代理对象；
      在通过生成的代理对象，执行目标方法的时候，会先调用mapperFactory.invoke()方法
      
      这里和mybaytis+spring整合之后，的区别是：原生的getMapper()获取到的代理对象 mapperProxy,在初始化的时候，传入的sqlSession是defaultSQLSession，而整合之后，mapperProxy在初始化时，传入的sqlSession是SqlSesisonTemplate，所以this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);
      
      那为什么和spring整合之后，sqlSession就变成了SqlSessionTemplate？
      因为MapperFactoryBean是继承了SqlSessionDaoSupport,在SqlSessionDaoSupport中会进行setSqlSessionFactory()，在这里,this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);
      所以，在mapperFactoryBean中getObject()的时候，this.sqlSession.getMapper()就会进到sqlSessionTemplate中，在getMapper中，初始化了代理对象，this.sqlSession = new SqlSessionTemplate(sqlSessionFactory);所以这里就是SqlSessionTemplate
      
      
   mybatis对于@Select这种情况，是在mapperFactoryBean中checkDaoConfig()方法，在那当前接口添加到mappedStatement的时候，org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.parseStatement,会调用这个方法，把注解的信息取到，然后包装成mappedStatement